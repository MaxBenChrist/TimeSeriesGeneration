# Autogenerated with SMOP 0.32-7-gcce8558
from smop.core import *
# MkSg_map.m

    
@function
def MkSg_Map(mapName=None,N=None,s0=None,params=None,eta=None,*args,**kwargs):
    varargin = MkSg_Map.varargin
    nargin = MkSg_Map.nargin

    # returns a time series obtained from given conservative map from the
# list of maps in Chaos and Time-Series Analysis by J. C. Sprott
# Output is a signal, s, that has as each column an output from a coordinate of
# the specified map
#-------------------------------------------------------------------------------
    
    ## Set broad defaults
    if nargin < 1 or isempty(mapName):
        mapName='Chirikov'
    
    if nargin < 2 or isempty(N):
        N=1000
    
    if nargin < 5 or isempty(eta):
        eta=500
    
    # Set other defaults within each specific map
    
    if 'Chirikov' == mapName:
        ## Chirikov (standard) map
		# Sprott conservative map
		# parameter is k
		# Set defaults
        if nargin < 3 or isempty(s0):
            s0=matlabarray(cat(0.1,6))
        if nargin < 4 or isempty(params):
            params=1
        # Initialize
        x=zeros(N + eta,1)
        y=zeros(N + eta,1)
        x[1]=s0[1]
        y[1]=s0[2]
        k=copy(params)
        for i in arange(2,N + eta).reshape(-1):
            y[i]=mod(y[i - 1] + dot(k,sin(x[i - 1])),dot(2,pi))
            x[i]=mod(x[i - 1] + y[i],dot(2,pi))
        # Remove transient
        x=x[1 + eta:end()]
        y=y[1 + eta:end()]
        s=matlabarray(cat(x,y))
    else:
        if 'Henonqm' == mapName:
            ## Henon area-preserving quadratic map
		# Sprott conservative map
		# Parameter is alpha
		# Set defaults
            if nargin < 3 or isempty(s0):
                s0=matlabarray(cat(0.6,0.13))
            if nargin < 4 or isempty(params):
                params=acos(0.24)
            # Initialize
            x=zeros(N + eta,1)
            y=zeros(N + eta,1)
            x[1]=s0[1]
            y[1]=s0[2]
            alpha=copy(params)
            for i in arange(2,N + eta).reshape(-1):
                x[i]=dot(x[i - 1],cos(alpha)) - dot((y[i - 1] - x[i - 1] ** 2),sin(alpha))
                y[i]=dot(x[i - 1],sin(alpha)) + dot((y[i - 1] - x[i - 1] ** 2),cos(alpha))
            # Remove transient
            x=x[1 + eta:end()]
            y=y[1 + eta:end()]
            s=matlabarray(cat(x,y))
        else:
            if 'Arnold' == mapName:
                ## Arnold's cat map
		# Sprott conservative map
		# Set defaults
                if nargin < 3 or isempty(s0):
                    s0=matlabarray(cat(0,1 / sqrt(2)))
                if nargin < 4 or isempty(params):
                    params=2
                # Initialize
                x=zeros(N + eta,1)
                y=zeros(N + eta,1)
                x[1]=s0[1]
                y[1]=s0[2]
                k=copy(params)
                for i in arange(2,N + eta).reshape(-1):
                    x[i]=mod(x[i - 1] + y[i - 1],1)
                    y[i]=mod(x[i - 1] + dot(k,y[i - 1]),1)
                # Remove transient
                x=x[1 + eta:end()]
                y=y[1 + eta:end()]
                s=matlabarray(cat(x,y))
            else:
                if 'Gingerbreadman' == mapName:
                    ## Gingerbreadman map
		# Sprott conservative map
		# Set defaults
                    if nargin < 3 or isempty(s0):
                        s0=matlabarray(cat(0.51,3.7))
                    # Initialize
                    x=zeros(N + eta,1)
                    y=zeros(N + eta,1)
                    x[1]=s0[1]
                    y[1]=s0[2]
                    # Simulate the map
                    for i in arange(2,N + eta).reshape(-1):
                        x[i]=1 + abs(x[i - 1]) - y[i - 1]
                        y[i]=x[i - 1]
                    # Remove transient
                    x=x[1 + eta:end()]
                    y=y[1 + eta:end()]
                    s=matlabarray(cat(x,y))
                else:
                    if 'Chaoticweb' == mapName:
                        ## Chaotic web map
		# Sprott conservative map
		# Set defaults
                        if nargin < 3 or isempty(s0):
                            s0=matlabarray(cat(0,2.98))
                        if nargin < 4 or isempty(params):
                            params=matlabarray(cat(pi / 2,1))
                        # Initialize
                        x=zeros(N + eta,1)
                        y=zeros(N + eta,1)
                        x[1]=s0[1]
                        y[1]=s0[2]
                        alpha=params[1]
                        k=params[2]
                        for i in arange(2,N + eta).reshape(-1):
                            x[i]=dot(x[i - 1],cos(alpha)) - dot((y[i - 1] + dot(k,sin(x[i - 1]))),sin(alpha))
                            y[i]=dot(x[i - 1],sin(alpha)) + dot((y[i - 1] + dot(k,sin(x[i - 1]))),cos(alpha))
                        # Remove transient
                        x=x[1 + eta:end()]
                        y=y[1 + eta:end()]
                        s=matlabarray(cat(x,y))
                    else:
                        if 'Lorenz3d' == mapName:
                            ## Lorenz 3D chaotic map
		# Sprott conservative map
		# Set defaults
                            if nargin < 3 or isempty(s0):
                                s0=matlabarray(cat(0.5,0.51,- 0.99))
                            # Initialize
                            x=zeros(N + eta,1)
                            y=zeros(N + eta,1)
                            z=zeros(N + eta,1)
                            x[1]=s0[1]
                            y[1]=s0[2]
                            z[1]=s0[3]
                            # Simulate the map
                            for i in arange(2,N + eta).reshape(-1):
                                x[i]=dot(x[i - 1],y[i - 1]) - z[i - 1]
                                y[i]=x[i - 1]
                                z[i]=y[i - 1]
                            # Remove transient
                            x=x[1 + eta:end()]
                            y=y[1 + eta:end()]
                            z=z[1 + eta:end()]
                            s=matlabarray(cat(x,y,z))
                            ### Sprott: Dissipative Maps
                        else:
                            if 'Henon' == mapName:
                                ## Henon map
		# Sprott dissipative map
		# Set defaults
                                if nargin < 3 or isempty(s0):
                                    s0=matlabarray(cat(0.1,0.8))
                                if nargin < 4 or isempty(params):
                                    params=matlabarray(cat(1.4,0.3))
                                # Initialize
                                x=zeros(N + eta,1)
                                y=zeros(N + eta,1)
                                x[1]=s0[1]
                                y[1]=s0[2]
                                a=params[1]
                                b=params[2]
                                for i in arange(2,N + eta).reshape(-1):
                                    x[i]=1 - dot(a,x[i - 1] ** 2) + dot(b,y[i - 1])
                                    y[i]=x[i - 1]
                                # Remove transient
                                x=x[1 + eta:end()]
                                y=y[1 + eta:end()]
                                s=matlabarray(cat(x,y))
                            else:
                                if 'Lozi' == mapName:
                                    ## Lozi map
		# Sprott dissipative map
		# Set defaults
                                    if nargin < 3 or isempty(s0):
                                        s0=matlabarray(cat(- 0.2,0.1))
                                    if nargin < 4 or isempty(params):
                                        params=matlabarray(cat(1.7,0.5))
                                    # Initialize
                                    x=zeros(N + eta,1)
                                    y=zeros(N + eta,1)
                                    x[1]=s0[1]
                                    y[1]=s0[2]
                                    a=params[1]
                                    b=params[2]
                                    for i in arange(2,N + eta).reshape(-1):
                                        x[i]=1 - dot(a,abs(x[i - 1])) + dot(b,y[i - 1])
                                        y[i]=x[i - 1]
                                    # Remove transient
                                    x=x[1 + eta:end()]
                                    y=y[1 + eta:end()]
                                    s=matlabarray(cat(x,y))
                                else:
                                    if 'DelayedLogistic' == mapName:
                                        ## Delayed logistic map
		# Sprott dissipative map
		# Set defaults
                                        if nargin < 3 or isempty(s0):
                                            s0=matlabarray(cat(0.001,0.001))
                                        if nargin < 4 or isempty(params):
                                            params=2.27
                                        # Initialize
                                        x=zeros(N + eta,1)
                                        y=zeros(N + eta,1)
                                        x[1]=s0[1]
                                        y[1]=s0[2]
                                        A=copy(params)
                                        for i in arange(2,N + eta).reshape(-1):
                                            x[i]=dot(dot(A,x[i - 1]),(1 - y[i - 1]))
                                            y[i]=x[i - 1]
                                        # Remove transient
                                        x=x[1 + eta:end()]
                                        y=y[1 + eta:end()]
                                        s=matlabarray(cat(x,y))
                                    else:
                                        if 'Tinkerbell' == mapName:
                                            ## Tinkerbell map
		# Sprott dissipative maps
		# Set defaults
                                            if nargin < 3 or isempty(s0):
                                                s0=matlabarray(cat(0.1,0.4))
                                            if nargin < 4 or isempty(params):
                                                params=matlabarray(cat(0.9,- 0.6,2,0.5))
                                            # Initialize
                                            x=zeros(N + eta,1)
                                            y=zeros(N + eta,1)
                                            x[1]=s0[1]
                                            y[1]=s0[2]
                                            a=params[1]
                                            b=params[2]
                                            c=params[3]
                                            d=params[4]
                                            for i in arange(2,N + eta).reshape(-1):
                                                x[i]=x[i - 1] ** 2 - y[i - 1] ** 2 + dot(a,x[i - 1]) + dot(b,y[i - 1])
                                                y[i]=dot(dot(2,x[i - 1]),y[i - 1]) + dot(c,x[i - 1]) + dot(d,y[i - 1])
                                            # Remove transient
                                            x=x[1 + eta:end()]
                                            y=y[1 + eta:end()]
                                            s=matlabarray(cat(x,y))
                                        else:
                                            if 'Burgers' == mapName:
                                                ## Burgers map
		# Sprott dissipative maps
		# Set defaults
                                                if nargin < 3 or isempty(s0):
                                                    s0=matlabarray(cat(- 0.2,0.1))
                                                if nargin < 4 or isempty(params):
                                                    params=matlabarray(cat(0.75,1.75))
                                                # Initialize
                                                x=zeros(N + eta,1)
                                                y=zeros(N + eta,1)
                                                x[1]=s0[1]
                                                y[1]=s0[2]
                                                a=params[1]
                                                b=params[2]
                                                for i in arange(2,N + eta).reshape(-1):
                                                    x[i]=dot(a,x[i - 1]) - y[i - 1] ** 2
                                                    y[i]=dot(b,y[i - 1]) + dot(x[i - 1],y[i - 1])
                                                # Remove transient
                                                x=x[1 + eta:end()]
                                                y=y[1 + eta:end()]
                                                s=matlabarray(cat(x,y))
                                            else:
                                                if 'HolmesCubic' == mapName:
                                                    ## Holmes Cubic map
		# Sprott dissipative maps
		# Set defaults
                                                    if nargin < 3 or isempty(s0):
                                                        s0=matlabarray(cat(1.7,0))
                                                    if nargin < 4 or isempty(params):
                                                        params=matlabarray(cat(0.2,2.77))
                                                    # Initialize
                                                    x=zeros(N + eta,1)
                                                    y=zeros(N + eta,1)
                                                    x[1]=s0[1]
                                                    y[1]=s0[2]
                                                    b=params[1]
                                                    d=params[2]
                                                    for i in arange(2,N + eta).reshape(-1):
                                                        x[i]=y[i - 1]
                                                        y[i]=dot(- b,x[i - 1]) + dot(d,y[i - 1]) - y[i - 1] ** 3
                                                    # Remove transient
                                                    x=x[1 + eta:end()]
                                                    y=y[1 + eta:end()]
                                                    s=matlabarray(cat(x,y))
                                                else:
                                                    if 'KaplanYorke' == mapName:
                                                        ## Kaplan-Yorke map
		# Sprott dissipative maps
		# Set defaults
                                                        if nargin < 3 or isempty(s0):
                                                            s0=matlabarray(cat(1 / sqrt(2),- 0.4))
                                                        if nargin < 4 or isempty(params):
                                                            params=matlabarray(cat(1.99999999,0.2))
                                                        # Initialize
                                                        x=zeros(N + eta,1)
                                                        y=zeros(N + eta,1)
                                                        x[1]=s0[1]
                                                        y[1]=s0[2]
                                                        a=params[1]
                                                        b=params[2]
                                                        for i in arange(2,N + eta).reshape(-1):
                                                            x[i]=mod(dot(a,x[i - 1]),1)
                                                            y[i]=mod(dot(b,y[i - 1]) + cos(dot(dot(4,pi),x[i - 1])),1)
                                                        # Remove transient
                                                        x=x[1 + eta:end()]
                                                        y=y[1 + eta:end()]
                                                        s=matlabarray(cat(x,y))
                                                    else:
                                                        if 'DissipativeStandard' == mapName:
                                                            ## Dissipative Standard map
		# Sprott dissipative maps
		# Set defaults
                                                            if nargin < 3 or isempty(s0):
                                                                s0=matlabarray(cat(1 / sqrt(2),- 0.4))
                                                            if nargin < 4 or isempty(params):
                                                                params=matlabarray(cat(0.1,8.8))
                                                            # Initialize
                                                            x=zeros(N + eta,1)
                                                            y=zeros(N + eta,1)
                                                            x[1]=s0[1]
                                                            y[1]=s0[2]
                                                            b=params[1]
                                                            k=params[2]
                                                            for i in arange(2,N + eta).reshape(-1):
                                                                y[i]=mod(dot(b,y[i - 1]) + dot(k,sin(x[i - 1])),dot(2,pi))
                                                                x[i]=mod(x[i - 1] + y[i],dot(2,pi))
                                                            # Remove transient
                                                            x=x[1 + eta:end()]
                                                            y=y[1 + eta:end()]
                                                            s=matlabarray(cat(x,y))
                                                        else:
                                                            if 'Ikeda' == mapName:
                                                                ## Ikeda map
		# Sprott dissipative maps
		# Set defaults
                                                                if nargin < 3 or isempty(s0):
                                                                    s0=matlabarray(cat(0.05,0))
                                                                if nargin < 4 or isempty(params):
                                                                    params=matlabarray(cat(6,0.4,1,0.9))
                                                                # Initialize
                                                                x=zeros(N + eta,1)
                                                                y=zeros(N + eta,1)
                                                                x[1]=s0[1]
                                                                y[1]=s0[2]
                                                                alpha=params[1]
                                                                beta=params[2]
                                                                gamma=params[3]
                                                                mu=params[4]
                                                                for i in arange(2,N + eta).reshape(-1):
                                                                    theta=beta - alpha / (1 + x[i - 1] ** 2 + y[i - 1] ** 2)
                                                                    x[i]=gamma + dot(mu,(dot(x[i - 1],cos(theta)) - dot(y[i - 1],sin(theta))))
                                                                    y[i]=dot(mu,(dot(x[i - 1],sin(theta)) + dot(y[i - 1],cos(theta))))
                                                                # Remove transient
                                                                x=x[1 + eta:end()]
                                                                y=y[1 + eta:end()]
                                                                s=matlabarray(cat(x,y))
                                                            else:
                                                                if 'Sinai' == mapName:
                                                                    ## Sinai map
		# Sprott dissipative maps
		# Set defaults
                                                                    if nargin < 3 or isempty(s0):
                                                                        s0=matlabarray(cat(0.5,0.5))
                                                                    if nargin < 4 or isempty(params):
                                                                        params=0.1
                                                                    # Initialize
                                                                    x=zeros(N + eta,1)
                                                                    y=zeros(N + eta,1)
                                                                    x[1]=s0[1]
                                                                    y[1]=s0[2]
                                                                    delta=copy(params)
                                                                    for i in arange(2,N + eta).reshape(-1):
                                                                        x[i]=mod(x[i - 1] + y[i - 1] + dot(delta,cos(dot(dot(2,pi),y[i - 1]))),1)
                                                                        y[i]=mod(x[i - 1] + dot(2,y[i - 1]),1)
                                                                    # Remove transient
                                                                    x=x[1 + eta:end()]
                                                                    y=y[1 + eta:end()]
                                                                    s=matlabarray(cat(x,y))
                                                                else:
                                                                    if 'PredatorPrey' == mapName:
                                                                        ## Discrete Predator-Prey Map
		# Sprott dissipative maps
		# Set defaults
                                                                        if nargin < 3 or isempty(s0):
                                                                            s0=matlabarray(cat(0.5,0.5))
                                                                        if nargin < 4 or isempty(params):
                                                                            params=matlabarray(cat(0.3,1,5))
                                                                        # Initialize
                                                                        x=zeros(N + eta,1)
                                                                        y=zeros(N + eta,1)
                                                                        x[1]=s0[1]
                                                                        y[1]=s0[2]
                                                                        r=params[1]
                                                                        K=params[2]
                                                                        alpha=params[3]
                                                                        for i in arange(2,N + eta).reshape(-1):
                                                                            x[i]=dot(x[i - 1],exp(dot(r,(1 - x[i - 1] / K)) - dot(alpha,y[i - 1])))
                                                                            y[i]=dot(x[i - 1],(1 - exp(dot(- alpha,y[i - 1]))))
                                                                        # Remove transient
                                                                        x=x[1 + eta:end()]
                                                                        y=y[1 + eta:end()]
                                                                        s=matlabarray(cat(x,y))
                                                                    else:
                                                                        if 'FreitasStochasticSine' == mapName:
                                                                            ## Freitas stochastic sine map
		# Map from the literature: Freitas, Letellier, Aguirre: PRE 79,035201(R) (2009)
		# x_{n+1},0 = mu*sin(x_n) + Y_n*eta_n
		# Y_n is Bernoulii: y=binornd(1,q,[]) q is the probability y=1
		# eta is (cts) uniform random: eta=unifrnd(-b,b,[]) with magnitude b
		# So when q=0, it's a sine map on a period-2 limit cycle, otherwise it
		# occasionally gets kicked, perhaps to another limit cycle (there are two fixed
		# points -- at -2 and at 2)
                                                                            # Set defaults
                                                                            if nargin < 3 or isempty(s0):
                                                                                s0=unifrnd(- 1,1,1)
                                                                            if nargin < 4 or isempty(params):
                                                                                params=matlabarray(cat(2.4,1,0.1))
                                                                            # Parameters
                                                                            mu=params[1]
                                                                            b=params[2]
                                                                            q=params[3]
                                                                            # Initialize
                                                                            x=zeros(N + eta,1)
                                                                            y=binornd(1,q,cat(N + eta,1))
                                                                            n=unifrnd(- b,b,cat(N + eta,1))
                                                                            x[1]=s0
                                                                            for i in arange(2,N + eta).reshape(-1):
                                                                                x[i]=dot(mu,sin(x[i - 1])) + dot(y[i],n[i])
                                                                            # Remove transient
                                                                            x=x[1 + eta:end()]
                                                                            s=copy(x)
                                                                        else:
                                                                            if 'FreitasNonlinearMA' == mapName:
                                                                                ## Freita's Nonlinear Moving Average Filter
		# Map from the literature: Freitas, Letellier, Aguirre: PRE 79,035201(R) (2009)
		# A nonlinear moving average filter of uniform random noise:
		# x_{n},0 = a*u_n + b*u_{n-1},0*(1-u_n)
		# The paper didn't give values for the parameters a and b:
		# I have just used uniform random numbers for both a and b between -5 and 5,
		# Getting a new value at each iteration, and with each interation receiving two occurances [1 2]
		# initial condition is also uniform continuous random [-5 5]
                                                                                # Set defaults
                                                                                if nargin < 3 or isempty(s0):
                                                                                    s0=unifrnd(- 5,5,1)
                                                                                if nargin < 4 or isempty(params):
                                                                                    params=matlabarray(cat(2,1))
                                                                                # Initialize
                                                                                x=zeros(N + eta,1)
                                                                                u=unifrnd(0,1,cat(N + eta,1))
                                                                                x[1]=s0
                                                                                a=params[1]
                                                                                b=params[2]
                                                                                for i in arange(2,N + eta).reshape(-1):
                                                                                    x[i]=dot(a,u[i]) + dot(dot(b,u[i - 1]),(1 - u[i]))
                                                                                # Remove transient
                                                                                x=x[1 + eta:end()]
                                                                                s=copy(x)
                                                                            else:
                                                                                if 'CaoPeriodic' == mapName:
                                                                                    ## Cao Periodic Map
		# To show his method for determining the dimension he uses this four-dimensional system:
		# x_{n+4},0 = sin(x_n+5) + sin(2x_{n+1},0+5) + sin(3x_{n+2},0+5) + sin(4x_{n+3},0+5)
		# Not quite autoregressive... Nonlinear autoregressive maybe?
		# Set defaults
                                                                                    if nargin < 3 or isempty(s0):
                                                                                        s0=rand(4,1)
                                                                                    # Initialize
                                                                                    x=zeros(N + eta,1)
                                                                                    x[1:4]=s0
                                                                                    for i in arange(5,N + eta).reshape(-1):
                                                                                        x[i]=sin(x[i - 4] + 5) + sin(dot(2,x[i - 3]) + 5) + sin(dot(3,x[i - 2]) + 5) + sin(dot(4,x[i - 1]) + 5)
                                                                                    # Remove transient
                                                                                    x=x[1 + eta:end()]
                                                                                    s=copy(x)
                                                                                    ### Sprott's Noninvertible Maps
# Appendix A.1 of his book
                                                                                else:
                                                                                    if 'logistic' == mapName:
                                                                                        ## Logistic Map
		# Set defaults
                                                                                        if nargin < 3 or isempty(s0):
                                                                                            s0=0.1
                                                                                        if nargin < 4 or isempty(params):
                                                                                            params=4
                                                                                        # Initialize
                                                                                        x=zeros(N + eta,1)
                                                                                        x[1]=s0
                                                                                        A=copy(params)
                                                                                        for i in arange(2,N + eta).reshape(-1):
                                                                                            x[i]=dot(dot(A,x[i - 1]),(1 - x[i - 1]))
                                                                                        # Remove transient as signal to return
                                                                                        s=x[1 + eta:end()]
                                                                                    else:
                                                                                        if 'sine' == mapName:
                                                                                            ## Sine Map
		# Set defaults
                                                                                            if nargin < 3 or isempty(s0):
                                                                                                s0=0.1
                                                                                            if nargin < 4 or isempty(params):
                                                                                                params=1
                                                                                            # Initialize
                                                                                            x=zeros(N + eta,1)
                                                                                            x[1]=s0
                                                                                            A=copy(params)
                                                                                            for i in arange(2,N + eta).reshape(-1):
                                                                                                x[i]=dot(A,sin(dot(pi,x[i - 1])))
                                                                                            # Remove transient as signal to return
                                                                                            s=x[1 + eta:end()]
                                                                                        else:
                                                                                            if 'tent' == mapName:
                                                                                                ## Tent Map
		# Set defaults
                                                                                                if nargin < 3 or isempty(s0):
                                                                                                    s0=1 / sqrt(2)
                                                                                                if nargin < 4 or isempty(params):
                                                                                                    params=1.9999999
                                                                                                # Initialize
                                                                                                x=zeros(N + eta,1)
                                                                                                x[1]=s0
                                                                                                A=copy(params)
                                                                                                for i in arange(2,N + eta).reshape(-1):
                                                                                                    x[i]=dot(A,min(cat(x[i - 1],1 - x[i - 1])))
                                                                                                # Remove transient as signal to return
                                                                                                s=x[1 + eta:end()]
                                                                                            else:
                                                                                                if 'lincongen' == mapName:
                                                                                                    ## Linear Congruential Generator
		# Set defaults
                                                                                                    if nargin < 3 or isempty(s0):
                                                                                                        s0=0.1
                                                                                                    if nargin < 4 or isempty(params):
                                                                                                        params=matlabarray(cat(7141,54773,259200))
                                                                                                    # Initialize
                                                                                                    x=zeros(N + eta,1)
                                                                                                    x[1]=s0
                                                                                                    A=params[1]
                                                                                                    B=params[2]
                                                                                                    C=params[3]
                                                                                                    for i in arange(2,N + eta).reshape(-1):
                                                                                                        x[i]=mod(dot(A,x[i - 1]) + B,C)
                                                                                                    # Remove transient as signal to return
                                                                                                    s=x[1 + eta:end()]
                                                                                                else:
                                                                                                    if 'cubic' == mapName:
                                                                                                        ## Cubic Map
		# Set defaults
                                                                                                        if nargin < 3 or isempty(s0):
                                                                                                            s0=0.1
                                                                                                        if nargin < 4 or isempty(params):
                                                                                                            params=2.6
                                                                                                        # Initialize
                                                                                                        x=zeros(N + eta,1)
                                                                                                        x[1]=s0
                                                                                                        A=copy(params)
                                                                                                        for i in arange(2,N + eta).reshape(-1):
                                                                                                            x[i]=dot(dot(A,x[i - 1]),(1 - x[i - 1] ** 2))
                                                                                                        # Remove transient as signal to return
                                                                                                        s=x[1 + eta:end()]
                                                                                                    else:
                                                                                                        if 'rickerspopulation' == mapName:
                                                                                                            ## Ricker's Population Model
		# Set defaults
                                                                                                            if nargin < 3 or isempty(s0):
                                                                                                                s0=0.1
                                                                                                            if nargin < 4 or isempty(params):
                                                                                                                params=20
                                                                                                            # Initialize
                                                                                                            x=zeros(N + eta,1)
                                                                                                            x[1]=s0
                                                                                                            A=copy(params)
                                                                                                            for i in arange(2,N + eta).reshape(-1):
                                                                                                                x[i]=dot(dot(A,x[i - 1]),exp(- x[i - 1]))
                                                                                                            # Remove transient as signal to return
                                                                                                            s=x[1 + eta:end()]
                                                                                                        else:
                                                                                                            if 'Gauss' == mapName:
                                                                                                                ## Gauss map
		# Set defaults
                                                                                                                if nargin < 3 or isempty(s0):
                                                                                                                    s0=0.1
                                                                                                                # Initialize
                                                                                                                x=zeros(N + eta,1)
                                                                                                                x[1]=s0
                                                                                                                for i in arange(2,N + eta).reshape(-1):
                                                                                                                    x[i]=mod(1 / x[i - 1],1)
                                                                                                                # Remove transient as signal to return
                                                                                                                s=x[1 + eta:end()]
                                                                                                            else:
                                                                                                                if 'Cusp' == mapName:
                                                                                                                    ## Cusp map
		# Set defaults
                                                                                                                    if nargin < 3 or isempty(s0):
                                                                                                                        s0=0.1
                                                                                                                    if nargin < 4 or isempty(params):
                                                                                                                        params=1.95
                                                                                                                    # Initialize
                                                                                                                    x=zeros(N + eta,1)
                                                                                                                    x[1]=s0
                                                                                                                    A=copy(params)
                                                                                                                    for i in arange(2,N + eta).reshape(-1):
                                                                                                                        x[i]=1 - dot(A,sqrt(abs(x[i - 1])))
                                                                                                                    # Remove transient as signal to return
                                                                                                                    s=x[1 + eta:end()]
                                                                                                                else:
                                                                                                                    if 'GaussWCM' == mapName:
                                                                                                                        ## Gaussian white chaotic map
		# Set defaults
                                                                                                                        if nargin < 3 or isempty(s0):
                                                                                                                            s0=0.1
                                                                                                                        # Initialize
                                                                                                                        x=zeros(N + eta,1)
                                                                                                                        x[1]=s0
                                                                                                                        for i in arange(2,N + eta).reshape(-1):
                                                                                                                            x[i]=abs(x[i - 1]) ** (- 0.25) - 0.5 - abs(x[i - 1])
                                                                                                                            #           x(i)=A*erfinv(1-2*erf(x(i-1)/A)); # Gaussian white chaotic map DOESN'T WORK
                                                                                                                        # Remove transient as signal to return
                                                                                                                        s=x[1 + eta:end()]
                                                                                                                    else:
                                                                                                                        if 'Pinchers' == mapName:
                                                                                                                            ## Pinchers Map
		# Set defaults
                                                                                                                            if nargin < 3 or isempty(s0):
                                                                                                                                s0=0
                                                                                                                            if nargin < 4 or isempty(params):
                                                                                                                                params=matlabarray(cat(2,0.5))
                                                                                                                            # Initialize
                                                                                                                            x=zeros(N + eta,1)
                                                                                                                            x[1]=s0
                                                                                                                            s=params[1]
                                                                                                                            c=params[2]
                                                                                                                            for i in arange(2,N + eta).reshape(-1):
                                                                                                                                x[i]=abs(tanh(dot(s,(x[i - 1] - c))))
                                                                                                                            # Remove transient as signal to return
                                                                                                                            s=x[1 + eta:end()]
                                                                                                                        else:
                                                                                                                            if 'Spence' == mapName:
                                                                                                                                ## Spence Map
		# Set defaults
                                                                                                                                if nargin < 3 or isempty(s0):
                                                                                                                                    s0=0.1
                                                                                                                                # Initialize
                                                                                                                                x=zeros(N + eta,1)
                                                                                                                                x[1]=s0
                                                                                                                                for i in arange(2,N + eta).reshape(-1):
                                                                                                                                    x[i]=abs(log(x[i - 1]))
                                                                                                                                # Remove transient as signal to return
                                                                                                                                s=x[1 + eta:end()]
                                                                                                                            else:
                                                                                                                                if 'Sinecircle' == mapName:
                                                                                                                                    ## Sine-circle Map
		# Set defaults
                                                                                                                                    if nargin < 3 or isempty(s0):
                                                                                                                                        s0=0
                                                                                                                                    if nargin < 4 or isempty(params):
                                                                                                                                        params=matlabarray(cat(2.1,0.44))
                                                                                                                                    # Initialize
                                                                                                                                    x=zeros(N + eta,1)
                                                                                                                                    x[1]=s0
                                                                                                                                    K=params[1]
                                                                                                                                    Omega=params[2]
                                                                                                                                    for i in arange(2,N + eta).reshape(-1):
                                                                                                                                        x[i]=mod(x[i - 1] + Omega - dot(K / (dot(2,pi)),sin(dot(dot(2,pi),x[i - 1]))),1)
                                                                                                                                    # Remove transient as signal to return
                                                                                                                                    s=x[1 + eta:end()]
                                                                                                                                    ### More Maps
                                                                                                                                else:
                                                                                                                                    if 'Julia' == mapName:
                                                                                                                                        ## Julia Map
		# Not sure where I got this map from. It's probably mentioned in Sprott.
		# Can't get it to do anything interesting
		# Set defaults
                                                                                                                                        if nargin < 3 or isempty(s0):
                                                                                                                                            s0=matlabarray(cat(0.1,0.1))
                                                                                                                                        # Initialize
                                                                                                                                        x=zeros(N + eta,1)
                                                                                                                                        y=zeros(N + eta,1)
                                                                                                                                        x[1]=s0[1]
                                                                                                                                        y[1]=s0[2]
                                                                                                                                        for i in arange(2,N + eta).reshape(-1):
                                                                                                                                            x[i]=x[i - 1] ** 2 - y[i - 1] ** 2 - 1
                                                                                                                                            y[i]=dot(dot(2,x[i - 1]),y[i - 1])
                                                                                                                                        # Remove transient as signal to return
                                                                                                                                        s=matlabarray(cat(x[1 + eta:end()],y[1 + eta:end()]))
                                                                                                                                    else:
                                                                                                                                        disp(cat('Invalid map name'))
                                                                                                                                        s=copy(NaN)
                                                                                                                                        return s
    
    return s
    
if __name__ == '__main__':
    pass
    